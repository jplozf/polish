package stack

// *****************************************************************************
//  __________      .__  .__       .__
//  \______   \____ |  | |__| _____|  |__
//   |     ___/  _ \|  | |  |/  ___/  |  \
//   |    |  (  <_> )  |_|  |\___ \|   Y  \
//   |____|   \____/|____/__/____  >___|  /
//                               \/     \/
//
//          Polish Â© jpl@ozf.fr 2024
//
// *****************************************************************************

// *****************************************************************************
// IMPORTS
// *****************************************************************************
import (
	"errors"
	"sync"
)

// *****************************************************************************
// TYPES
// *****************************************************************************
type FStack struct {
	lock sync.Mutex // you don't have to do this if you don't want thread safety
	S    []float64
}

type AStack struct {
	lock sync.Mutex // you don't have to do this if you don't want thread safety
	S    []string
}

// *****************************************************************************
// NewFStack()
// *****************************************************************************
func NewFStack() *FStack {
	return &FStack{sync.Mutex{}, make([]float64, 0)}
}

// *****************************************************************************
// Push()
// *****************************************************************************
func (s *FStack) Push(v float64) {
	s.lock.Lock()
	defer s.lock.Unlock()

	s.S = append(s.S, v)
}

// *****************************************************************************
// Pop()
// *****************************************************************************
func (s *FStack) Pop() (float64, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	l := len(s.S)
	if l == 0 {
		return 0, errors.New("empty float stack")
	}

	res := s.S[l-1]
	s.S = s.S[:l-1]
	return res, nil
}

// *****************************************************************************
// Depth()
// *****************************************************************************
func (s *FStack) Depth() int {
	return len(s.S)
}

// *****************************************************************************
// NewAStack()
// *****************************************************************************
func NewAStack() *AStack {
	return &AStack{sync.Mutex{}, make([]string, 0)}
}

// *****************************************************************************
// Push()
// *****************************************************************************
func (s *AStack) Push(v string) {
	s.lock.Lock()
	defer s.lock.Unlock()

	s.S = append(s.S, v)
}

// *****************************************************************************
// Pop()
// *****************************************************************************
func (s *AStack) Pop() (string, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	l := len(s.S)
	if l == 0 {
		return "", errors.New("empty string stack")
	}

	res := s.S[l-1]
	s.S = s.S[:l-1]
	return res, nil
}

// *****************************************************************************
// Depth()
// *****************************************************************************
func (s *AStack) Depth() int {
	return len(s.S)
}
