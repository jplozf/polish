package program

// *****************************************************************************
//  __________      .__  .__       .__
//  \______   \____ |  | |__| _____|  |__
//   |     ___/  _ \|  | |  |/  ___/  |  \
//   |    |  (  <_> )  |_|  |\___ \|   Y  \
//   |____|   \____/|____/__/____  >___|  /
//                               \/     \/
//
//          Polish Â© jpl@ozf.fr 2024
//
// *****************************************************************************

// *****************************************************************************
// IMPORTS
// *****************************************************************************
import (
	"crypto/rand"
	"encoding/hex"
	"errors"
	"sync"
)

// *****************************************************************************
// TYPES
// *****************************************************************************
type Program []string
type PStack struct {
	lock sync.Mutex // you don't have to do this if you don't want thread safety
	S    []Program
}

// *****************************************************************************
// GLOBALS
// *****************************************************************************
var Programs map[string]Program
var TmpProgram Program
var sub int // 0 = main program
var currentSub int
var subPrograms []Program

// *****************************************************************************
// NewPStack()
// *****************************************************************************
func NewPStack() *PStack {
	return &PStack{sync.Mutex{}, make([]Program, 0)}
}

// *****************************************************************************
// Push()
// *****************************************************************************
func (s *PStack) Push(p Program) {
	s.lock.Lock()
	defer s.lock.Unlock()

	s.S = append(s.S, p)
}

// *****************************************************************************
// Pop()
// *****************************************************************************
func (s *PStack) Pop() (Program, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	l := len(s.S)
	if l == 0 {
		return nil, errors.New("empty program stack")
	}

	res := s.S[l-1]
	s.S = s.S[:l-1]
	return res, nil
}

// *****************************************************************************
// Depth()
// *****************************************************************************
func (s *PStack) Depth() int {
	return len(s.S)
}

// *****************************************************************************
// init()
// *****************************************************************************
func init() {
	Programs = make(map[string]Program)
	sub = 0
}

// *****************************************************************************
// GetSubLevel()
// *****************************************************************************
func GetSubLevel() int {
	return sub
}

// *****************************************************************************
// NewSub()
// *****************************************************************************
func NewSub() {
	if sub != 0 {
		// There is a previous sub in TmpProgram in progress, we have to save it before
		subPrograms = append(subPrograms, TmpProgram)
	}
	sub++
	TmpProgram = nil
	currentSub = sub
}

// *****************************************************************************
// EndSub()
// *****************************************************************************
func EndSub() {
	if sub > 0 {
		subPrograms[sub] = TmpProgram
		sub--
		currentSub = sub

	}
}

// *****************************************************************************
// StoreWord()
// *****************************************************************************
func StoreWord(w string) {
	TmpProgram = append(TmpProgram, w)
	// subPrograms = append(subPrograms)
}

// *****************************************************************************
// StoreProgram()
// *****************************************************************************
func StoreProgram(name string, program Program) string {
	if name == "" {
		pfx, _ := RandomHex(6)
		name = "sub_" + pfx
	}
	Programs[name] = program
	return name
}

// ****************************************************************************
// RandomHex()
// ****************************************************************************
func RandomHex(n int) (string, error) {
	bytes := make([]byte, n)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return hex.EncodeToString(bytes), nil
}

/*

{ 45 36 { 23 5 } 17 }
tmp...




*/
