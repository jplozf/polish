package stack

// *****************************************************************************
//  __________      .__  .__       .__
//  \______   \____ |  | |__| _____|  |__
//   |     ___/  _ \|  | |  |/  ___/  |  \
//   |    |  (  <_> )  |_|  |\___ \|   Y  \
//   |____|   \____/|____/__/____  >___|  /
//                               \/     \/
//
//          Polish Â© jpl@ozf.fr 2024
//
// *****************************************************************************

import (
	"errors"
	"sync"
)

type Stack struct {
	lock sync.Mutex // you don't have to do this if you don't want thread safety
	S    []float64
}

// *****************************************************************************
// NewStack()
// *****************************************************************************
func NewStack() *Stack {
	return &Stack{sync.Mutex{}, make([]float64, 0)}
}

// *****************************************************************************
// Push()
// *****************************************************************************
func (s *Stack) Push(v float64) {
	s.lock.Lock()
	defer s.lock.Unlock()

	s.S = append(s.S, v)
}

// *****************************************************************************
// Pop()
// *****************************************************************************
func (s *Stack) Pop() (float64, error) {
	s.lock.Lock()
	defer s.lock.Unlock()

	l := len(s.S)
	if l == 0 {
		return 0, errors.New("empty stack")
	}

	res := s.S[l-1]
	s.S = s.S[:l-1]
	return res, nil
}

// *****************************************************************************
// Depth()
// *****************************************************************************
func (s *Stack) Depth() int {
	return len(s.S)
}
